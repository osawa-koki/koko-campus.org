<?php
require(__DIR__. "/../../framework/ver3/common.php");
$obj = array(
	"made" => "2022-05-10",
	"updated" => "2022-05-10"
);
head($obj);
?>
<h2>パフォーマンス</h2>
データベースはその名の通り、大量のデータを格納することが仕事です。<br />その大量のデータから一部のデータを抽出して処理をするのには膨大な時間がかかります。<br /><br />そのため、データベースには高速での処理をサポートするための技術がたくさん用意されています。<br />しかしながら、それらの技術をただ利用すればok!ということではなく、その技術を正しく理解して適切に使用する必要があります。<br /><br />ということで、ここではデータベース処理のパフォーマンスを向上させる方法について説明します。
<div class="separator"></div>
因みに、パフォーマンスってとっても大切です。<br />ページを表示しようとしてもロードするのに何秒もかかったらユーザは不満を感じますよね、、、<br /><br />実際、ページのロード時間とコンバージョン率には強い相関があることが報告されています。
<ul>
	<li><a href="https://neilpatel.com/blog/loading-time/?wide=1">ロード時間が1秒増加するとコンバージョン率は7%低下する。</a></li>
	<li><a href="https://www.thinkwithgoogle.com/intl/en-ca/marketing-strategies/app-and-mobile/mobile-page-speed-new-industry-benchmarks/">表示速度が1秒から3秒まで落ちると、直帰率は32%増加する。</a></li>
</ul>
これ以外にも調べると、ページの表示速度とコンバージョン率の関係についての記事はたくさんでてきます。<br /><br />「0.1秒」の違いであってもユーザの満足度に大きな影響を与えます。<br /><br />データベースのパフォーマンスはデータベースエンジニアとしては絶対に意識しなければならないことだと認識できましたか???<br /><br />では、早速データベースのパフォーマンス向上技術について学びましょう♪
<h2>実行プラン(オプティマイザ)</h2>
DBMSがSQLを解釈して実行する方法として以下の2通りがあります。
<ul>
	<li>ルールベースオプティマイザ</li>
	<li>コストベースオプティマイザ</li>
</ul>
<h3>ルールベースオプティマイザ</h3>
SQL文をそのまま解釈してデータベース操作を実行します。<br />したがって、プログラマがどのようにSQL文を書くかがパフォーマンスに影響を与えます。<br /><br />今ではほとんど用いられていませんが、古いバージョンを使用している場合にはSQLの最適化を図る必要があります。<br /><br />SQL Serverはルールベースオプティマイザを採用していませんので、SQL文自体を気にする必要はありません。
<h3>コストベースオプティマイザ</h3>
DBMSがSQL文から自動でどのような処理をするかを判断します。<br />SQL Serverはコストベースオプティマイザを採用しているため、SQL文の書き方によってパフォーマンスに差が出るということはほとんどありません。<br /><br />処理を判断する際に使用する統計情報等からパフォーマンスに若干の違いが出ることもありますが、、、
<div class="separator"></div>
一応、SQL ServerがSQLを実行する仕組みを紹介します。<br />SQL Serverは受け取ったSQLを以下の工程を経て命令文に変換して実行します。
<ol>
	<li>文法解析</li>
	<li>定義解析</li>
	<li>最適化</li>
	<li>実行プランをキャッシュ</li>
	<li>処理の実行</li>
</ol>
<img src="../pics/実行プランの理解.jpg" alt="実行プラン" />
<p>画像は<a href="https://atmarkit.itmedia.co.jp/ait/articles/1703/20/news001.html">アイティメディア</a>より。</p>
大切なのは最適な処理を実行するために使用する統計情報を最適な状態に保つ努力です。<br /><br />ということで、統計情報についてもう少し学びましょう♪
<h3>統計情報</h3>


<h2>インデックス</h2>
インデックスとは、索引の意味で大量にあるデータを効率的に探索するための仕組みです。<br /><br />インデックスが付いていないと、ページ単位で全体スキャンをかけるため、時間がかかるという問題があります。<br /><br />主キーとして設定したカラムに対しては自動的にインデックスが付与されます。<br /><br />では、インデックスを設定してSQLが正しくインデックスを使用して処理を行っているかを確認しましょう♪<br />最初にインデックスを設定していない状態で画面を右クリックして「Display Estimated Execution Plan」をクリックして下さい。<br />実行するSQL文は以下のものとします。
<code class="sql">
	SELECT *
	FROM pokemon
	WHERE number = 10;
</code>
<img src="../pics/実行プラン(インデックスなし).gif" alt="実行プラン" />
「Table Scan」と表示されているのが確認できます。<br />これはテーブルを全てスキャンしていることを意味します。<br /><br />次にインデックスを設定して確認してみましょう♪<br />プライマリーキー(インデックス)の設定方法は既に説明しましたが覚えていますか???<br /><br />復習がてらにもう一度説明します。<br /><br />テーブルを右クリックして「Design」を選択、表示された画面のうち、プライマリーキーまたはインデックスを選択して保存してください。<br /><br />では、先ほどのSQL文をもう一度実行しましょう♪
<code class="sql">
	SELECT *
	FROM pokemon
	WHERE number = 10;
</code>
<img src="../pics/実行プラン(インデックス有り).gif" alt="実行プラン" />
今度は「Clustered Index Seek」と表示されています。<br />これはインデックスを使用して検索をかけたことを意味しています。
<h3>インデックスのデメリット</h3>
インデックスは正しく設定するとデータベース処理のパフォーマンス向上につながりますが、索引データの構造が適切でない場合や票の更新等でインデックスデータを作り変える必要が多いとパフォーマンスの低下につながります。<br /><br />また、以下に該当する場合にはインデックスはパフォーマンスの向上につながりません。
<ul>
	<li>LIKE句を使用して部分一致・後方一致で検索する場合</li>
	<li>NULLで検索する場合</li>
	<li>暗黙の型変換を使用する場合</li>
	<li>NOT条件の場合</li>
	<li>関数を使用してWHERE句を使用している場合</li>
</ul>
<h2>Clusterd Index Scan</h2>
データが小さすぎる場合にはインデックスを使用せずにテーブルをスキャンした方が早くなることがあります。<br />DBMSではこれを自動的に判断してインデックスを使用せずに処理を実行することがあります。<br />これを「Clusterd Index Scan」と言います。<br /><br />では、データの上位10件だけを含む新しいテーブルを作成しましょう♪<br /><br />因みにデータをコピーする際には以下のSQL文で実行可能です。
<code class="sql">
	SELECT *
	INTO コピー先テーブル
	FROM コピー元テーブル;
</code>
今回は全てのデータをコピーするのではなく、上位10件だけをコピーするため、以下のようなSQL文となります。
<code class="sql">
	SELECT TOP 10 *
	INTO poke_small
	FROM pokemon;
</code>
<img src="../pics/insert-into.gif" alt="INSERT INTO" />
では、このデータに対して先ほどインデックスを使用して実行したSQL文を発行してみましょう♪
<code class="sql">
	SELECT *
	FROM poke_small
	WHERE number = 10;
</code>
<img src="../pics/実行プラン(インデックス不使用).gif" alt="実行プラン" />




<h2>ストアドプロシージャ</h2>





<?php footer(); ?>