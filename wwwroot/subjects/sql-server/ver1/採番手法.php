<?php
require(__DIR__. "/../../framework/ver3/common.php");
$obj = array(
	"made" => "2022-05-10",
	"updated" => "2022-05-10"
);
head($obj);
?>
<h2>採番</h2>
IDなどの重複がないデータはどのように生成すればいいでしょうか???<br /><br />ランダムな文字列を生成する方法を思い浮かべる方も多いと思います。<br />しかしながら、この方法だと重複する危険性もゼロではありません。<br /><br />登録する数が増えると爆発的に増加していきます。<br />興味があれば「誕生日攻撃」で調べてみて下さい。<br /><br />一番安全な方法は連番を使用することです。<br />「0」「1」「2」...という感じです。<br /><br />しかしながら、最後に使用した数を取得して「+1」をする必要があります。<br /><br />これって結構面倒くさいんです。<br />テーブルのIDを全て取得して一番大きい数を選択して、、、って方法をとるとパフォーマンスを大きく低下させることになるため、これとは別に管理する必要があります。<br /><br />う～～～ん、、、<br /><br />大変ですね、、、<br /><br />ということで、採番を実行する処理をストアドプロシージャとして一括化しましょう♪
<h2>採番テーブル</h2>
最後に使用したIDを管理するテーブルを作成し、そのテーブルでは連番を必要とするテーブル名と最後に使用した数の2つを管理します。
<img src="../pics/採番テーブル.gif" alt="採番テーブル" />
「0」から始めるのはダサいと思う方はテキトーに「1000」くらいの数字から始めてもok!です。<br />INT型の上限である「-2<sup>31</sup>(-2,147,483,648) ～ +2<sup>31</sup>-1(2,147,483,647)」を超えないように注意して下さいね♪<br /><br />このテーブルを採番管理専用に使用しましょう♪<br /><br />このテーブルはストアドプロシージャ専用でプログラマがSQLから直接処理することはありません。
<h2>採番ストアド</h2>
呼び出す際には採番対象のテーブル名を引数として渡します。<br />呼び出された場合には、最後に使用した数に「+1」した数を新たに採番用のテーブルに登録して、その値を返すようにします。<br /><br />ということで、僕が作成したストアドプロシージャを紹介します。
<code class="sql">
	CREATE PROCEDURE call_counter
		@id CHAR(10)
		AS BEGIN
			DECLARE @i INT;
			SET NOCOUNT ON;
			SET @i = -1;

			UPDATE a
				SET @i = a.value,
				a.value = @i + 1
			FROM counter a with(rowlock, updlock)
			WHERE a.id = @id;

			RETURN @i;
		END
</code>
実際に使用してみましょう♪
<code class="sql">
	USE koko;
	DECLARE @n INT;
	EXEC @n = dbo.call_counter @id = 'student'

	INSERT student(id, name, grade)
	VALUES (@n, 'ストアド太郎', 1);

	SELECT * FROM student;
</code>
<img class="no-max" src="../pics/カウンタープロシージャの実行.gif" alt="カウンタープロシージャの実行" />
ストアドプロシージャの戻り値を変数に格納するためには以下のように書きます。
<code class="sql">
	EXEC @変数 = ストアドプロシージャ名;
</code>
「前回使用したID + 1」が戻り値として返されます。<br />また、同時に採番テーブルの値も自動で更新されます。
<h2>IDENTITY</h2>










<?php footer(); ?>