<?php
require(__DIR__. "/../../framework/ver3/common.php");
$obj = array(
	"made" => "2022-05-10",
	"updated" => "2022-05-10"
);
head($obj);
?>
<h2>トランザクション</h2>
トランザクションとは、絶対に分けることができない処理の集まりを言います。<br /><br />例えば、銀行での振り込みをイメージして下さい。<br />Aさんが、Bさんに一万円を振り込みます。<br /><br />Aさんの銀行口座から一万円を引いて、Bさんの銀行口座に一万円を加算するわけですが、この最中に停電が発生して処理がストップされたとします。<br /><br />この場合、Aさんの口座からは一万円引かれているが、Bさんの口座に一万円が振り込まれていないため、一万円が消滅した状態が発生します。<br />これは絶対に許されません。<br />停電が発生しようが、サーバがダウンしようが振り込みにおいて、減算と加算のいずれかのみが行われるということは絶対にありません。<br /><br />これを実現する技術がトランザクション制御です。<br /><br />トランザクションは以下の4つの性質を備えている必要があります。
<div class="scroll-600w">
	<table>
		<caption>ACID特性</caption>
		<tbody>
			<tr>
				<th><strong>A</strong>tomicity</th>
				<td>原子性<br />トランザクションは「全て実行される」か「まったく実行されない」のどちらかです。<br />少しだけ実行されるのはありえません。</td>
			</tr>
			<tr>
				<th><strong>C</strong>onsintency</th>
				<td>一貫性<br />トランザクションはデータベースの内容に矛盾を生じさせません。</td>
			</tr>
			<tr>
				<th><strong>I</strong>solation</th>
				<td>独立性<br />トランザクションは他のトランザクションの影響を受けません。</td>
			</tr>
			<tr>
				<th><strong>D</strong>urability</th>
				<td>永続性<br />一度正常に終了したトランザクションの実行結果は失われません。</td>
			</tr>
		</tbody>
	</table>
</div>
<div class="separator"></div>
では、今回使用するデータセットを紹介します。<br />今回は銀行の口座情報テーブルを使用します。
<img src="../pics/bank-account.gif" alt="トランザクションで使用するデータセット" />
僕は常に金欠で、彼女は高給です。<br />僕が彼女にお金を恵んでもらいます。
<h2>コミットとロールバック</h2>
トランザクションの原子性を保証するための仕組みです。<br />トランザクションの開始点と終了点を指示して、問題なく実行されたらコミット(確定)して、中断されたらロールバック(取り消し)を行います。<br /><br />トランザクションは以下のように書きます。
<code class="sql">
	BEGIN TRAN; -- トランザクションの開始

	-- トランザクション処理...
	-- トランザクション処理...
	-- トランザクション処理...

	COMMIT; -- トランザクションの終了
</code>
では、僕が彼女に100万円恵んでもらいます。<br /><br />加算処理は可能で、減算処理に失敗するように設定しています。
<img class="no-max" src="../pics/commit.gif" alt="COMMIT" />
キチンとトランザクション制御が出来ていることが確認できます。<br /><br />一応、ロールバックも紹介します。<br />トランザクションに失敗した場合はトランザクション開始時点まで戻します。
<img class="no-max" src="../pics/rollback.gif" alt="ロールバック処理" />
<h2>ロック</h2>
先ほどはトランザクション中の処理の中断に対応しましたが、今回は同時に処理を実行したことによる不整合を防ぐ技術を紹介します。<br /><br />例えば、クレジットカードで10000円のお買い物をしたとします。<br />その時点ではクレジットカードの利用可能額残高は20000ありました。<br /><br />これを確認した後に、クレジットカードの利用承認を出します。<br /><br />利用承認を得られた決済器は決済を完了させて、それを伝えます。<br /><br />これを受けてクレジットカードの利用可能残高を10000円分減額する必要がありますが、この間に他のシステムから利用可能残額を減算されていたら困りますよね、、、<br /><br />これを防ぐための仕組みがロックです。<br /><br />データを使用中に設定して、その間は他のプロセスがそのレコードを使用不可にします。
<div class="separator"></div>
といっても我々プログラマがロックをかける必要はありません。<br />通常の処理はロックを必要とするため、デフォルトでロックがかかります。<br /><br />ロックには以下の2種類があります。
<div class="scroll-600w">
	<table>
		<tbody>
			<tr>
				<th>共有ロック</th>
				<td>「S_LOCK」と言います。<br />共有ロック同士であれば同時に処理可能です。<br />同じデータを何人で見ても問題ないですよね♪<br />これはSELECT文で行われます。</td>
			</tr>
			<tr>
				<th>占有ロック</th>
				<td>「X_LOCK」と言います。<br />他のプロセスの処理を許しません。<br />SELECT文以外で行われます。</td>
			</tr>
		</tbody>
	</table>
</div>
共有ロック同士ならばok!、それ以外はng!と覚えてください。<br />大切なので、もう一度言います。<br />共有ロック同士ならばok!、それ以外はng!と覚えてください。
<div class="separator"></div>
先ほど、SQLを実行したときに処理が実行されませんでしたよね、、、<br />あれは実は、裏側ロックをかけていて強制的に処理を実行させていませんでした。<br />もっと正確に説明すると、トランザクションを開始させた後にコミットをせずに永遠にロックをかけていました。<br /><br />では、実演してみましょう♪
<h3>共有ロック同士</h3>
こちらは特に問題なく処理を行うことができます。
<img class="no-max" src="../pics/共有ロック.gif" alt="共有ロック同士" />
<h3>共有ロック同士以外</h3>
こちらは、不可です。<br />しかしながら、ロックがかかっているデータに対して、見るだけ(SELECT)であれば、「with(nolock)」キーワードを設定すれば可能です。
<img class="no-max" src="../pics/with(nolock).gif" alt="with(nolock)" />
<div class="separator"></div>
SELECT文をかかる共有ロックは正確には一瞬だけかかりますので、想像と異なる挙動になることがあります。
<img src="../pics/瞬間Sロック.gif" alt="瞬間Sロック" />
別に覚えなくてもok!ですが、、、
<h2>トランザクションの分離レベル</h2>
トランザクションの分離レベルについて説明する前に、同時にレコードを操作することによって生じる副作用を3つ紹介します。
<div class="scroll-600w">
	<table>
		<tbody>
			<tr>
				<th>ダーティリード</th>
				<td>「dirty read」で汚い読みという意味です。<br />コミットされていない未確定の変更を他の人が読めてしまう問題を言います。</td>
			</tr>
			<tr>
				<th>ノンリピータブルリード</th>
				<td>あるデータをSELECT文で取得した後に誰かがそのデータに変更を加えた場合、次回のSELECT文の結果が異なってします問題です。<br />変更を加えているわけですから当然と言えば当然ですが、実務上問題となることが多いです。</td>
			</tr>
			<tr>
				<th>ファントムリード</th>
				<td>ノンリピータブルリードとほとんど同じです。<br />ファントムリードはSELECT文で変更を加える代わりにINSET文で行を追加することで発生する不整合です。</td>
			</tr>
		</tbody>
	</table>
</div>
では、本題に入ります。<br />トランザクションの分離レベルによって同時処理の副作用のうち、どこまでを許容するかを設定できます。<br /><br />分離レベルには以下の4つがあり、下の方が安全になっています。
<ol>
	<li>READ UNCOMMITED</li>
	<li>READ COMMITED</li>
	<li>REPEATABLE READ</li>
	<li>SERIALIZABLE</li>
</ol>
一番安全な「SERIALIZABLE」にすればいいじゃんと思うかもしれませんが、安全にすればするほど実行効率は低下します。<br />一般的には「READ COMMITED」が使用されることが多いです。<br /><br />参考までに、それぞれの分離レベルが副作用のどれを許容するかを紹介します。
<div class="scroll-600w">
	<table>
		<caption>トランザクション分離レベル</caption>
		<thead>
			<tr>
				<th>分離レベル</th>
				<th>ダーティーリード</th>
				<th>ノンリピータブルリード</th>
				<th>ファントムリード</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<th>READ UNCOMMITTED</th>
				<td class="トランザクション分離レベル-危険">危険</td>
				<td class="トランザクション分離レベル-危険">危険</td>
				<td class="トランザクション分離レベル-危険">危険</td>
			</tr>
			<tr>
				<th>READ COMMITTED</th>
				<td class="トランザクション分離レベル-安全">安全</td>
				<td class="トランザクション分離レベル-危険">危険</td>
				<td class="トランザクション分離レベル-危険">危険</td>
			</tr>
			<tr>
				<th>REPEATABLE READ</th>
				<td class="トランザクション分離レベル-安全">安全</td>
				<td class="トランザクション分離レベル-安全">安全</td>
				<td class="トランザクション分離レベル-危険">危険</td>
			</tr>
			<tr>
				<th>SERIALIZABLE</th>
				<td class="トランザクション分離レベル-安全">安全</td>
				<td class="トランザクション分離レベル-安全">安全</td>
				<td class="トランザクション分離レベル-安全">安全</td>
			</tr>
		</tbody>
	</table>
</div>
現在のトランザクション分離レベルを確認するには以下のSQLを実行します。
<code class="sql">
	DBCC USEROPTIONS;
</code>
<img src="../pics/トランザクション分離レベル-確認.gif" alt="トランザクション分離レベル" />
トランザクション分離レベルを変更するには以下のSQLを実行します。
<code class="sql">
	SET TRANSACTION ISOLATION LEVEL レベル名
</code>
<h2>デッドロック</h2>
複数の処理がロックをかけていて、かつお互いがお互いのロックの解除を待ちあっている状態です。<br /><br />日常生活で例えるならば、AさんとBさんが映画に行くかどうかを話し合っている状態を想像してください。<br />Aさんは「Bさんが行くなら行く」と言っていて、Bさんは「Aさんが行くなら行く」と言っています。<br /><br />これはどうしようもないですよね、、、<br /><br />これがデッドロック状態です。<br /><br />これを防ぐためには「資源のロック順序を統一する」必要があります。<br /><br />また、保険的な案として以下の2つを意識する必要があります。
<ul>
	<li>ロック対象の資源範囲は最小限で</li>
	<li>ロック時間は必要最小限で</li>
</ul>
実演します。<br />クエリエディタを2つ用意して、以下の処理を行ってください。<br />因みに、範囲を選択して実行をするとその範囲だけ実行されます。
<ul>
	<li>クエリ1で資源1をロック(トランザクション開始)</li>
	<li>クエリ2で資源2をロック(トランザクション開始)</li>
	<li>クエリ1で資源2にアクセス(待機)</li>
	<li>クエリ2で資源1にアクセス(待機)</li>
	<li>デッドロックの発生</li>
</ul>
<img class="no-max" src="../pics/デッドロック.gif" alt="デッドロック" />
<?php footer(); ?>