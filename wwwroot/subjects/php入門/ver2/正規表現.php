<?php
require(__DIR__. "/../../framework/ver3/common.php");
$obj = array(
	"made" => "2022-02-01",
	"updated" => "2022-02-01"
);
head($obj);
?>
<h2>正規表現とは</h2>
ある文字列から、一定のパターンの文字列を検索・置換するための技術です。<br /><br />例えば「101-8301」「1018301」は郵便番号として適切ですが、「koko-love」「1010-8301」「10-10-10-10」は郵便番号ではないですよね、、、<br /><br />こういった文字列のパターンを正規表現で定義します。<br /><br />正規表現について現在僕が勉強している本は「500」ページ以上あるんです、、、<br />とっても奥が深いです。<br /><br />ここでは簡単な、よく用いる正規表現について学びましょう♪<br />興味がある方は正規表現入門も学んでみて下さい。<br />とっても面白いですよ♪
<a class="link to-正規表現入門" href="../../正規表現入門/branch">正規表現入門</a>
<h2>書き方</h2>
phpでは正規表現は文字列として書き出します。<br />具体的には「"正規表現"」としますが、この文字列をデリミタ(区切り文字)で囲む必要があります。<br /><br />デリミタとして使用可能な文字はいくつかありますが、ここではもっとも一般的な「//(スラッシュ)」を用います。<br /><br />「"/正規表現/"」こんな感じですね♪<br /><br />また正規表現を用いた関数については後ほど学習しますが、正規表現の説明に用いるため「preg_match()」関数だけ簡単にここで説明します。
<h3>preg_match()</h3>
ある文字列に含まれる、正規表現で示されたパターンにマッチする部分を取得します。
<code class="php">
	preg_match("/正規表現/", "対象文字列", マッチした文字列を格納する変数);
</code>
このコードでは対象文字列から正規表現にマッチした文字列を第三引数に渡した変数に格納します。<br />第三引数には正規表現実行結果に関する情報(サブマッチパターン)が配列形式で格納されます。<br />マッチした文字列は最初に格納されているため、インデックス番号「0」を指定して取り出します。<br />サブマッチパターンに関してはここでは気にしなくてok!です。<br /><br />戻り値にはマッチした場合には「1」が、マッチしなかった場合には「0」が格納されるため、これを使用して条件分岐を実現します。
<code class="php">
	if (preg_match("/正規表現/", "対象文字列") === 1) {
		//マッチした場合の処理
	} else {
		//マッチしなかった場合の処理
	}
</code>
条件式は「1」の場合(「0」以外の数字)は真、「0」の場合は偽となるため、省略して以下のように書くこともできます。
<code class="php">
	if (preg_match("/正規表現/", "対象文字列")) {
		//マッチした場合の処理
	} else {
		//マッチしなかった場合の処理
	}
</code>
<h2>モード</h2>
正規表現にはモードという概念が存在して、正規表現を判定するアルゴリズムそのものの振る舞いを指定します。<br />具体的には以下の4つがあります。
<ul>
	<li>u</li>
	<li>i</li>
	<li>m</li>
	<li>s</li>
</ul>
<h3>u</h3>
マルチバイトモードで、原則としてこれを用いることをオススメします。<br />使用しなくても良い場面はチェック対象が半角英数字だけと限定されている場合です。
<h3>i</h3>
大文字と小文字を区別しない設定です。<br />このモードに設定すると「APPLE」「Apple」「apple」を同じ文字列と認識します。
<h3>m</h3>
マルチラインモードと呼ばれ、後ほど説明する「^」と「$」の動作を変更します。
<h3>s</h3>
ドット全マッチモードです。<br />後ほど説明する「.」の動作を変更します。
<h2>文字の指定</h2>
ここでは、以下の3つの記法を学びます。
<ul>
	<li>通常文字列</li>
	<li>「.(ドット)」</li>
	<li>「[](スクエアブラケット)」</li>
</ul>
<h3>通常文字列</h3>
ある文字列に含まれる文字列にマッチさせるにはその文字列をそのまま書きます。
<code class="php">
	preg_match("/めん/u", "らーめん", $m);
	echo $m[0]; //「めん」
</code>
<h3>「.(ドット)」</h3>
任意の一文字(改行文字を除く)を表します。<br />正規表現を「s」モードに設定すると改行文字にもマッチします。
<code class="php">
	preg_match("/./u", "らーめん", $m1);
	preg_match("/../u", "らーめん", $m2);

	echo $m1[0]; //「ら」
	echo $m2[0]; //「ら」「ー」
</code>
<h3>「[](スクエアブラケット)」</h3>
「[]」内の文字のうちのいずれかの文字にマッチさせます。
<code class="php">
	preg_match("/[かた]/", "らーめん", $m1);
	preg_match("/[かため]/", "らーめん", $m2);

	echo $m1[0]; //エラー(マッチしていない)
	echo $m2[0]; //「め」
</code>
<h4>[-]</h4>
「[](スクエアブラケット)」の中に「-(ハイフン)」を入れることで範囲を指定できます。<br />例えば「[a-z]」で「abcdefg...xyz」を意味し、「[0-9]」で「0123456789」を意味します。<br /><br />範囲といっても文字コードによるので全てを理解することは不可能ですので、こんなものがあるんだな程度でok!です。<br /><br />良く用いる範囲指定を紹介しますね♪
<table>
	<tbody>
		<tr>
			<th>[a-z]</th>
			<td>小文字のアルファベットを意味します。<br />「[abcdefg...xyz]」を意味します。</td>
		</tr>
		<tr>
			<th>[A-Z]</th>
			<td>小文字のアルファベットを意味します。<br />「[ABCDEFG...XYZ]」を意味します。</td>
		</tr>
		<tr>
			<th>[0-9]</th>
			<td>「[0123456789]」を意味します。</td>
		</tr>
		<tr>
			<th>[ぁ-ん]</th>
			<td>何だか卑猥な感じですが、、、笑<br />ひらがなを意味します。</td>
		</tr>
		<tr>
			<th>[ァ-ヶ]</th>
			<td>カタカナです。</td>
		</tr>
		<tr>
			<th>[亜-熙]</th>
			<td>漢字です。</td>
		</tr>
	</tbody>
</table>
複数組み合わせることも可能です。<br />例えば[a-zA-Z]でアルファベットを意味し、[ぁ-んァ-ヶ亜-熙]で日本語を意味します。
<code class="php">
	$target = $argv[1]; //ユーザが入力した文字をtarget変数に代入(無視してok!)
	if (preg_match("/[a-zA-Z]/u", $target)) {
		$answer[] = "英字";
	}
	if (preg_match("/[0-9]/u", $target)) {
		$answer[] = "数字";
	}
	if (preg_match("/[ぁ-んァ-ヶ亜-熙]/u", $target)) {
		$answer[] = "日本語文字";
	}
	echo explode("と", $answer). "が含まれます。";
</code>
<img src="../pics/cmd-preg_match(スクエアブラケット).gif" alt="正規表現" />
<h4>[^]</h4>
スクエアブラケットの否定バージョンです。<br />[^あいう]なら「あいう」以外の文字を意味します。
<code class="php">
	preg_match("/[^らー]/u", "らーめん", $m1);
	preg_match("/[^めん]/u", "らーめん", $m2);

	echo $m1[0]; //「め」
	echo $m2[0]; //「ら」
</code>
<h2>量指定子</h2>
直前の正規表現パターンの出現回数を指定します。<br />量指定子には以下のものがあります。
<table>
	<tbody>
		<tr>
			<th>「*」</th>
			<td>直前のパターンが「0」回以上連続している場合にマッチ</td>
		</tr>
		<tr>
			<th>「+」</th>
			<td>直前のパターンが「1」回以上連続している場合にマッチ</td>
		</tr>
		<tr>
			<th>「?」</th>
			<td>直前のパターンが「0」か「1」回現れる場合にマッチ</td>
		</tr>
		<tr>
			<th>「{n,}」</th>
			<td>直前のパターンが「n」回以上連続している場合にマッチ</td>
		</tr>
		<tr>
			<th>「{,N}」</th>
			<td>直前のパターンが「N」回以下連続している場合にマッチ</td>
		</tr>
		<tr>
			<th>「{n,N}」</th>
			<td>直前のパターンが「n」回以上「N」回以下連続している場合にマッチ</td>
		</tr>
	</tbody>
</table>
<h2>短縮系</h2>
よく使う正規表現パターンを簡単に表せるようにしたものです。
<table>
	<tbody>
		<tr>
			<th>「\d」</th>
			<td>数字にマッチ<br />[0-9]と同じ</td>
		</tr>
		<tr>
			<th>「\w」</th>
			<td>アルファベットとアンダースコアにマッチ<br />[a-zA-Z_]と同じ</td>
		</tr>
		<tr>
			<th>「\n」「\r」「\R」</th>
			<td>改行文字にマッチ<br />改行文字ってOSによって様々なんです、、、<br />原則「\n」を使っておけばok!です。</td>
		</tr>
		<tr>
			<th>「\t」</th>
			<td>タブ文字にマッチ</td>
		</tr>
		<tr>
			<th> (半角スペース)</th>
			<td>半角スペースはそのまま半角スペースを入力します。</td>
		</tr>
		<tr>
			<th>「\s」</th>
			<td>空白文字にマッチ<br />「\t」「\n」「r」「R」「半角スペース」にマッチ</td>
		</tr>
	</tbody>
</table>
<h2>位置指定子</h2>
「^」と「$」の2つあります。
<h3>^</h3>
対象文字列の先頭を意味します。<br />「m」モードだと各行の行頭にマッチします。
<code class="php">
	preg_match("/cde/", "abcde", $m); //$m[0]には「cde」が代入されます
	preg_match("/^cde/", "abcde", $m); //マッチしません
</code>
<h3>$</h3>
対象文字列の終わりを意味します。<br />「m」モードだと各行の行末にマッチします。
<code class="php">
	preg_match("/bcd/", "abcde", $m); //$m[0]には「bcd」が代入されます
	preg_match("/bcd$/", "abcde", $m); //マッチしません
</code>
<h2>組み合わせとグルーピング</h2>
正規表現パターンは「|(パイプ)」を用いて結合させることも可能です。<br />また、「()」を用いて正規表現パターンをグルーピングすることもできます。
<code class="php">
	preg_match("/(みそ|しょうゆ|しお)らーめん/", "とんこつらーめん"); //マッチしない、、、
	preg_match("/(みそ|しょうゆ|しお)らーめん/", "しょうゆらーめん"); //マッチ!!
	preg_match("/(みそ|しょうゆ|しお)らーめん/", "らーめん"); //マッチしない、、、
</code>
<h2>エスケープ</h2>
正規表現で「.(ドット)」を用いると任意の文字として扱われます。<br />同様に「\d」という文字列も任意の数字として扱われてしまいます。<br /><br />このように正規表現で特別な意味を持つ文字(特殊文字)を単なる文字として用いるためには特殊文字の前に「\(バックスラッシュ)」を付ける必要があります。
<p class="r">「\(バックスラッシュ)」は文字コードによっては円マークで表示されます。</p>
正規表現中でエスケープが必要な文字は以下の通りです。
<ul>
	<li>「.」</li>
	<li>「\」</li>
	<li>「*」</li>
	<li>「+」</li>
	<li>「?」</li>
	<li>「()」</li>
	<li>「{}」</li>
	<li>「[]」</li>
	<li>「^」</li>
	<li>「$」</li>
	<li>「|」</li>
</ul>
<h2>正規表現を用いる関数</h2>
正規表現とともに使用される関数には以下のものがあります。<br />PCRE関数とも呼ばれます。
<ul>
	<li>preg_match_all</li>
	<li>preg_match</li>
	<li>preg_replace</li>
	<li>preg_filter</li>
	<li>preg_grep</li>
	<li>preg_split</li>
</ul>
<p class="r">ちなみにこれらの関数の先頭にある「preg」は正規表現「regix」という意味です。</p>
<h3>preg_match_all</h3>
ある文字列から正規表現にマッチする全ての文字列を配列形式で取得します。<br />「preg_match_all(正規表現, 対象文字列, マッチした配列を代入する変数)」と書きます。<br />「preg_match()」関数同様に配列形式で格納されます。
<code class="php">
	$str = "xxx123xxx456xxx789";
	preg_match_all("/\d+/", $str, $m);
	echo $m[0][0]; //「123」と表示される
	echo $m[0][1]; //「456」と表示される
	echo $m[0][2]; //「789」と表示される
</code>
<h3>preg_replace</h3>
ある文字列の中の一定のパターンを別の文字列に置換します。
<code class="php">
	preg_replace(正規表現, 置換後文字列, 対象の文字列);
</code>
<code class="php">
	$str = "xxx123xxx456xxx789";
	echo preg_replace("/\d+/", "数字", $str); //「xxx数字xxx数字xxx数字」
</code>
また、置換後文字列に「""(空文字)」を指定することで対象のパターンを削除することも可能です。
<code class="php">
	$str = "xxx123xxx456xxx789";
	echo preg_replace("/\d+/", "", $str); //「xxxxxxxxx」
</code>
対象の文字列には配列を指定することも可能です。<br />この場合は戻り値も配列形式で返されます。
<code class="php">
	$ary = array(
		"xxx123xxx", "xxx456xxx", "xxx789xxx"
	);
	$replaced = preg_replace("/\d+/", "数字", $ary); //$replacedには「xxx数字xxx」「xxx数字xxx」「xxx数字xxx」が代入される
</code>
<h3>preg_filter</h3>
「preg_replace()」とほとんど同じです。<br />戻り値がマッチした結果 (を変換したもの) のみを返すという点で異なりますが、通常の使用では気にする必要はありません。
<h3>preg_grep</h3>
ある配列内の要素に対して正規表現検索を行って、マッチする文字列だけを含む新たな配列を戻り値として返します。
<code class="php">
	$ary = array(
		"abcde", "fg@ij", "k@mno", "pqr@@", "uvwxwz"
	);
	$matched = preg_grep("/[^@]/", "ary"); //$matchedには「abcde」「uvwxyz」が代入される
</code>
<h3>preg_split</h3>
ひとつ前の「配列の操作」の授業で文字列をある文字(区切り文字)で分割して配列を作成する「explode()」関数について学びましたね♪<br /><br />今回は区切り文字の部分に正規表現を使用します。
<code class="php">
	preg_split(正規表現, 対象の文字列);
</code>
<code class="php">
	$str = "あぁ,疲れたなぁ、あと少し,がんばろう!";
	$ary = preg_split("/,|、/", $str); //$aryには「あぁ」「疲れたなぁ」「あと少し」「がんばろう!」が格納されます
</code>
<?php footer(); ?>