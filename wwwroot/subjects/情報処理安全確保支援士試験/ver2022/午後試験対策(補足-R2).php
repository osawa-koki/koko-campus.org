<?php
require(__DIR__. "/../../framework/ver3.1/common.php");
$obj = array(
	"made" => "2022-03-18",
	"updated" => "2022-03-18"
);
head($obj);
?>
<p id="message">このページでは、令和2年の試験で出題された内容を説明をしています。<br /><br />それでは、Let's shout!!</p>
<h2>メッセージ認証</h2>
送信したデータ(メッセージ)がネットワーク上で不正に改竄されていないかを確認する技術のことを言います。<br />実装技術としては前回の授業で学んだ<a href="暗号?to=href_hash">ハッシュ関数</a>もしくは<a href="暗号?to=href_ckey">共通鍵暗号技術</a>を用います。<br /><br />代表的な方法としては、メッセージ認証コード(MAC)を使用する方法があげられます。<br /><br />以下でメッセージ認証に用いられる用語について説明しますね♪
<div class="scroll-600w">
	<table>
		<tr>
			<th>MAC</th>
			<td>メッセージ認証コード(Message Authentication Code)のことで、送信したデータがネットワーク上で改竄されていないかを確認するために使われます。<br /><br />共通鍵暗号を用いる「CMAC」とハッシュ関数を用いる「HMAC」とCBC暗号モードによる暗号を用いる「CBC-MAC」の3種類があります。</td>
		</tr>
		<tr>
			<th>HMAC</th>
			<td>ハッシュ関数はそのアルゴリズムが公開されているため攻撃者がハッシュ値をデータ改竄後にハッシュ値を再計算することが可能という問題があります。<br /><br />HMACではこの問題に対応するため、ハッシュ値の計算時に両者が共有している秘密鍵の値を加えることで第三者によるメッセージ改竄後のハッシュ値の再計算を防ぎます。</td>
		</tr>
		<tr>
			<th>CBC-MAC</th>
			<td>皆さん、<a href="暗号?to=href_mode">ブロック暗号方式の暗号モード</a>について覚えていますか???<br />「ECB」「CBC」「CFB」「OFB」の4つありましたよね♪<br />そのうちの「CBC」を利用するメッセージ認証技術です。<br />「CBC」暗号モードの特徴として前のブロックの暗号結果を利用して次のブロックを暗号する点があげられます。<br />換言すれば、平文がひとつでも変化すると結果も全く異なるものになります。<br /><br />「CBC-MAC」は固定長のメッセージに関しては安全性が保証されるんですけど、可変長のメッセージについては安全ではないとされるため、以下のCMACの利用が推奨されます。</td>
		</tr>
		<tr>
			<th>CMAC</th>
			<td>ブロック暗号(共有鍵暗号技術)を用いたメッセージ認証技術で前述した「CBC-MAC」が可変長のメッセージに関しては安全でないという問題を修正したものです。</td>
		</tr>
	</table>
</div>
メッセージ認証の問題点として以下の2つがあげられます。
<ul>
	<li>送信者の証明が不可(なりしましの危険性あり)</li>
	<li>否認防止が不可</li>
</ul>
このいずれもディジタル署名を用いることで解決できます。
<h2>サーバ証明書</h2>
ディジタル証明書のうち、サーバの真正性を保証するものを言います。<br />サーバ証明書には以下のフィールドがあります。
<div class="scroll-600w">
	<table>
		<tbody>
			<tr>
				<th>Version Number</th>
				<td>フォーマットのバージョン番号</td>
			</tr>
			<tr>
				<th>Serial Number</th>
				<td>シリアル番号</td>
			</tr>
			<tr>
				<th>Signature Algorithm ID</th>
				<td>署名アルゴリズムの識別情報</td>
			</tr>
			<tr>
				<th>Issuer Name</th>
				<td>認証局の名前</td>
			</tr>
			<tr>
				<th>Validity Period</th>
				<td>
					有効期限
					<ul>
						<li>Not Before(開始)</li>
						<li>Not After(終了)</li>
					</ul>
				</td>
			</tr>
			<tr>
				<th>Subject Name</th>
				<td>
					署名対象の名前
					<ul>
						<li></li>
						<li></li>
					</ul>
				</td>
			</tr>
			<tr>
				<th>Subject Public Key Info</th>
				<td>
					証明する公開鍵の情報
					<ul>
						<li>アルゴリズム(Public Key Algorithm)</li>
						<li>公開鍵(Subject Public Key)</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td colspan="2" class="center">～ 以下はオプション ～</td>
			</tr>
			<tr>
				<th>Issuer Unique Identifier</th>
				<td>認証局に付与される識別子</td>
			</tr>
			<tr>
				<th>Subject Unique Identifier</th>
				<td>認証対象に付与される識別子</td>
			</tr>
			<tr>
				<th>Extensions</th>
				<td>拡張領域</td>
			</tr>
		</tbody>
	</table>
</div>
「Subject Name」や「Issuer Name」に記述されている名称は、識別名(DN: Distinguished Name)と呼ばれ、以下の情報を保持します。
<ul>
	<li>C: Country(国)</li>
	<li>O: Organization(組織名)</li>
	<li>OU: Organization Unit(部門)</li>
	<li>CN: Common Name(一般)</li>
</ul>
<div class="separator"></div>
拡張領域で覚えておくべき内容に「Subject Alt Name」があります。<br /><br />SANと略され、サブジェクトの別名を設定する際に使用されます。<br /><br />異なるドメイン名を持つホスト名を1枚のサーバ証明書で証明できます。
<h3>検証方法</h3>
サーバ証明書を用いた検証方法では、具体的には以下の内容をチェックします。
<ul>
	<li>サーバ証明書の有効期限が切れていないこと</li>
	<li>サーバ証明書が失効状態でないこと</li>
	<li>サーバ証明書のコモンネームとアクセス先のFQDNが一致していること</li>
</ul>
<h3>パス構築</h3>
パス構築とは、階層構造をとるサーバ証明書に対して、CAを辿っていくことでサーバ証明書の真正性を確かめることです。<br /><br />具体的には以下の処理をします。
<ol>
	<li>IssuerからCA証明書を入手</li>
	<li>CA証明書のIssuerから、そのCA証明書を発行したCAの証明書を入手</li>
	<li>ルート証明書に到達するまで繰り返す</li>
</ol>
<h2>ディジタル署名・ディジタル証明書</h2>
ディジタル署名とディジタル証明書ってややこしいですよね、、、<br />たまに混同してしまうことがあります。<br /><br />ということで、ここでは両者の違いをしっかりとおさえましょう♪
<table>
	<thead>
		<tr>
			<th width="50%">ディジタル署名</th>
			<th width="50%">ディジタル証明書</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>「ハッシュ化」と「秘密鍵による暗号化(PKI)」の技術を組み合わせて作り出された電子的な<span class="underline">署名(ハンコ)</span>です。</td>
			<td>「ハッシュ化」と「秘密鍵による暗号化(PKI)」の技術を組み合わせて作り出された電子的な<span class="underline">身分証明書</span>です。</td>
		</tr>
	</tbody>
</table>
<h3>ディジタル署名</h3>
簡単に言えば、ハンコのディジタルバージョンです。<br />ハンコって本人であることを示すものですが、残念ながらハンコ自体は正当性を保証できません。<br /><br />例えば、僕が「佐倉まな」っていう名前のハンコを作成して、「佐倉まな」って偽ることもできてしまいます。<br /><br />実際のところ、これは現実世界でもかなり問題ですよね、、<br />「koko」って名前のハンコを誰かさんが勝手に作って、お金を借りました的な書類にそれを押して、、、<br />債権者が僕に対して、「ホラ、ハンコ押してあるやんけ!!」って主張して、、、<br /><br />これを防ぐ技術がディジタル証明書です。
<h3>ディジタル証明書</h3>
ハンコ(ディジタル署名)には問題があることを指摘しました。<br /><br />現実では、これをどうやって防いでいるでしょうか???<br /><br />正解は「印鑑証明書」です。<br />信頼できる第三者機関である市役所が僕のハンコに対して証明をしています。<br /><br />これがディジタルバージョンがディジタル証明書です。<br /><br />僕のディジタル証明書には、僕のディジタル署名に対する保証がなされています。<br /><br />ですが、ITの世界では市役所的な機関(信頼できる第三者)が現実とは異なります。<br />ITの世界では、信頼できる第三者機関が階層構造をとっています。<br /><br />したがって、信頼できる第三者機関のディジタル証明書にディジタル署名を付してその正当性を保証している、さらに信頼できる第三者機関の正当性を確認する必要があります。<br />そして、その第三者機関のディジタル証明書にディジタル署名を付してその正当性を保証している、さらに信頼できる第三者機関に対しても正当性を確認する必要があります。<br />そして、さらに、、、<br /><br />これを最上位に位置する信頼できる第三者機関まで到達するまで行います。<br /><br />最上位に位置する信頼できる第三者機関はルートCAと呼ばれ、ルートCAが発行しているディジタル証明をルート証明書と呼びます。<br />ルート証明書には、さらに信頼できる第三者機関は存在しないため、自分でディジタル署名を付します。<br />これを自己署名と言います。<br /><br />主な目的は、公開鍵の正当性を保証することです。
<?php footer(); ?>