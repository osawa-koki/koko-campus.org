<?php
require(__DIR__. "/../../framework/ver3/common.php");
$obj = array(
	"made" => "2022-02-14",
	"updated" => "2022-02-14"
);
head($obj);
?>
<h2>関数</h2>
関数とは一連の処理をまとめたもので、haskellにおいてはある引数から戻り値を求めるための処理の集合と言い換えられます。<br />haskellでは関数が引数から戻り値を求める以外の動作をするか否かで以下の2つに分類されます。
<ul>
	<li>純粋関数</li>
	<li>非純粋関数</li>
</ul>
<h3>純粋関数</h3>
引数から戻り値を求める以外の動作をしません。<br />したがって、関数外の変数を参照・変更したり、コンソールからの入出力やファイルへの読み書きの一切を禁止します。<br />また、引数から戻り値を求める以外の動作のことを<strong>関数の副作用</strong>と呼びますが、純粋関数ではこれを認めません。
<h3>非純粋関数</h3>
引数から戻り値を求める以外の動作をする関数です。<br />単なる処理の集まりと言い換えることができます。<br />他の言語ではサブルーチンや手続きという名称が用いられることがあります。<br />例えば、haskellプログラムへのエントリーポイントであるmain関数はコンソールへの入出力や関数外の変数の使用をしているため、非純粋関数に該当します。
<div class="separator"></div>
<img src="../pics/純粋関数・非純粋関数.png" alt="純粋関数 非純粋関数" />
<h2>関数の副作用</h2>
引数から戻り値を求める以外の動作のことを副作用と呼びことは説明しましたね♪<br />代表的な副作用にコンソール画面への出力やコンソール画面からの入力、関数外部の変数の使用、ファイルの読み書きがあります。<br /><br />ではなぜhaskellでは副作用の有無が大切なのでしょうか???<br /><br />答えとしてはhaskellでは関数を実行するのではなく、値に関数を適用するという考え方をとっているからです。<br />もっと言えば、数学的な意味での関数に近いということです。<br /><br />例えば、「y = 10x + 5」を想定してください。<br />xを引数として受け取ってyを戻り値として返します。<br />x(引数)が10ならばy(戻り値)は105であり、x(引数)が-5ならばy(戻り値)は-45となります。<br />これは関数が動作する環境には影響を受けず、常に成立します。<br /><br />haskellではこのような数学的な意味での関数を想定しているため、副作用があるか否かで純粋関数と非純粋関数に区分しています。
<div class="separator"></div>
haskell以外の言語でもこの考え方は大切です。<br />プログラムが複雑化すると関数が外部の変数(グローバル変数)を使用するとその管理が困難になります。<br />pythonやvb.netでは関数外部の変数を使用するのにglobal宣言が必要であるため極力関数外の変数を使用しないようにコーディングすると思いますが、javascriptではglobal宣言なく関数外の変数にアクセスできてしまうためプログラムが複雑化しやすいという危険性があります。<br /><br />是非haskellで純粋関数をマスターして他の言語でも綺麗なコードを書けるようになりましょう♪
<h2>関数の定義</h2>
関数は以下のように定義します。
<code class="haskell">
	関数名 引数1 引数2 引数3 = 関数内の処理
</code>
引数を「,(カンマ)」で区切る必要がないことに注意してください。<br /><br />では、「y = 2x<sup>2</sup> + 3x + 5」を計算する関数を作成してみましょう♪<br />関数名はfxとします。
<code class="haskell">
	fx x =  2 * x ** 2 + 3 * x + 5
</code>
<div class="separator"></div>
関数のデータ型を指定する場合には以下のように書きます。
<code class="haskell">
	関数名 :: 引数1のデータ型 -&gt; 引数2のデータ型 -&gt; 引数3のデータ型 ... -&gt; 戻り値のデータ型
</code>
では、先ほどのコードを関数のデータ型を指定して書き換えてみましょう♪
<code class="haskell">
	fx :: Float -&gt; Float
	fx x = 2 * x ** 2 + 3 * x + 5

	main :: IO ()
	main = do
		-- メイン関数の処理...
		-- メイン関数の処理...
</code>
累乗の計算は浮動小数点数型である必要があるため、引数と戻り値をともにFloat型で宣言しています。<br /><br />また、main関数のデータ型も定義しています。<br />main関数は標準入出力をすることも目的としているため、IO型として宣言しています。<br />IO型については詳しく理解する必要はありません。
<h2>関数の適用</h2>
今度は関数を実行してみましょう♪<br />正確にはhaskellでは関数を実行するないしは呼び出すとは言わずに、代わりに関数を引数に適用すると言います。<br /><br />ということで、言い直して、、、<br />今度は関数を引数に適用してみましょう♪
<code class="haskell">
	関数名 引数1 引数2 引数3
</code>
ここでも引数を「,(カンマ)」で区切る必要がないことに注意してください。<br /><br />では、先ほどの関数を様々な引数に適用して結果を確認しましょう♪
<code class="haskell">
	fx :: Float -&gt; Float
	fx x = 2 * x ** 2 + 3 * x + 5

	main :: IO ()
	main = do
		print (fx 5)
		print (fx 10)
		print (fx 15)

	{- &darr; コンソール &darr;
	70.0
	235.0
	500.0
	-}
</code>
<div class="separator"></div>
今度は引数を複数個持つ関数を定義して適用してみましょう♪<br />関数の式は「y = 3a + 2b + 4c + 0.3」とします。
<code class="haskell">
	fx :: Float -&gt; Float -&gt; Float -&gt; Float
	fx a b c = 3 * a + 2 * b + 4 * c + 0.3

	main :: IO ()
	main = do
		print (fx 1 2 3)
		print (fx 1 3 5)
		print (fx 5 5 5)

	{- &darr; コンソール &darr;
	19.3
	29.3
	45.3
	-}
</code>
後から型変換するのが面倒なので全て最初からFloat型で取得しています。
<h3>$による範囲の定義</h3>
結合の優先順位を示すためには括弧を用いることが多いですが、これが連鎖するとコードの可読性が損なわれます。<br />haskellでは、関数の引数が省略可能なのですが、関数型言語ということで関数を多用するとやはり括弧の数が増えてコードが見づらくなります。<br /><br />そこで、「$」を使用します。<br />「$」はその位置から行末までを自動で括弧で囲んでくれます。<br />例えば先ほどのコードは「$」を用いて以下のように書き換えられます。
<code class="haskell">
	fx :: Float -&gt; Float -&gt; Float -&gt; Float
	fx a b c = 3 * a + 2 * b + 4 * c + 0.3

	main :: IO ()
	main = do
		print $ fx 1 2 3
		print $ fx 1 3 5
		print $ fx 5 5 5

	{- &darr; コンソール &darr;
	19.3
	29.3
	45.3
	-}
</code>
<h2>再帰関数</h2>
関数型言語では関数を変数に適用するという考え方から変数の値を原則として変更しません。<br />したがって、forループなどで指定の回数分反復処理を繰り返してiを加算していくといった処理が推奨されません。<br />関数型言語では代わりに自分自身を呼び出す再帰関数を使用します。<br /><br />関数内で制限なく自分自身を呼び出すと無限ループに陥るため、関数内で条件分岐(場合分け)を用いて処理を制御します。<br />例えば、改行を求める関数を想定してください。<br />改行はnが「1」ならば「1」となり、それ以外ならば「n &times; n-1の階乗」となります。
<img src="../pics/階乗-場合分け.png" alt="再帰関数" />
さらに「n-1」が「1」ならば「1」となり、「n-1」が「1」以外ならば「(n-1) &times; (n-2)の階乗」となります。<br />以下、「n = 1」になるまでループ、、、<br /><br />これを再帰関数を用いて書いてみましょう♪
<code class="haskell">
	factorial :: Int -&gt; Int
	factorial x =
		if x == 0
			then 1
		else
			x * factorial (x - 1)

	main :: IO ()
	main = do
		print (factorial 5)
		print (factorial 7)
		print (factorial 15)

	{- &darr; コンソール &darr;
	120
	5040
	1307674368000
	-}
</code>
<h2>パターンマッチングを用いた関数定義</h2>
関数を引数の値によって別々に定義することができます。<br />以下のように書きます。
<code class="haskell">
	関数名 :: 引数のデータ型 -&gt; 戻り値のデータ型
	関数名 A = 関数の引数がAの場合の関数内の処理
	関数名 B = 関数の引数がBの場合の関数内の処理
	関数名 C = 関数の引数がCの場合の関数内の処理
</code>
では、階乗を求める関数をパターンマッチングによる関数定義を用いて書き換えてみましょう♪
<code class="haskell">
	factorial :: Int -&gt; Int
	factorial 0 = 1
	factorial x = x * factorial (x - 1)

	main :: IO ()
	main = do
		print $ factorial 5
		print $ factorial 7
		print $ factorial 15

	{- &darr; コンソール &darr;
	120
	5040
	1307674368000
	-}
</code>
<h2>ガードを用いた関数定義</h2>
パターンマッチングに「|(パイプ)」を用いて条件を課すことでガードを用いた関数定義が可能になります。<br />書き方はガードと同様です。<br /><br />では、先ほどの階乗を求める関数を使用してさらに大きな数の階乗を求めてみましょう♪
<code class="haskell">
	factorial :: Int -&gt; Int
	factorial 0 = 1
	factorial x = x * factorial (x - 1)

	main :: IO ()
	main = do
		print $ factorial 100
		print $ factorial 150
		print $ factorial 10000

	{- &darr; コンソール &darr;
	0
	0
	0
	-}
</code>
大きすぎて溢れてしまいました、、、<br />階乗って爆発的に大きくなりますからね、、、<br /><br />ということで、階乗を求める関数に10<sup>10</sup>以下という条件(ガード)を設定してみましょう♪<br />途中で10<sup>10</sup>を超えたら再帰を中止して無限大を返します。
<code class="haskell">
	factorial :: Float -&gt; Float
	factorial 0 = 1
	factorial x | x &lt;= 150 = x * factorial (x - 1)
				| otherwise = 1 / 0

	main :: IO ()
	main = do
		print $ factorial 10
		print $ factorial 15
		print $ factorial 20

	/* &darr; コンソール &darr;
	3628800.0
	1.3076743e12
	Infinity
	*/
</code>
<h2>ラムダ式</h2>
無記名関数とも呼ばれます。<br />名前がないため外部から呼び出して使用することができません。<br />したがって、ラムダ式は書いた部分で評価されます。<br />この性質から即時関数と呼ばれることもあります。<br />ラムダ式は以下のように記述します。
<code class="haskell">
	(\仮引数 -> 式) 実引数
</code>
仮引数とは関数が受け取る引数を言い、実引数とは関数へ渡す引数を言います。
<code class="haskell">
	main :: IO ()
	main = do
		print $ (\x -> x * x) 3
		print $ (\x -> x * x) 5
		print $ (\x -> x * x) 10

	{- &darr; コンソール &darr;
	9
	25
	100
	-}
</code>
<?php footer(); ?>