<?php
require(__DIR__. "/../../framework/ver3/common.php");
$obj = array(
	"made" => "2022-02-21",
	"updated" => "2022-02-21"
);
head($obj);
?>
<h2>オブジェクト指向</h2>
とっても理解するのが難しい考え方です。<br />プログラミングでは、データに着目してプログラムを作成するデータ中心アプローチとメソッド(処理)に着目してプログラムを作成するメソッド中心アプローチの2つがありますが、両者にはそれぞれデメリットがあります。<br /><br />オブジェクト指向ではデータとメソッドの両方を<strong>オブジェクト</strong>としてひとまとめにして、これを管理します。<br /><br />例えば、食べ物って食べますよね♪<br />さらには、食べ物には甘味・旨味・塩味・酸味・苦味の5つの要素からなります。<br /><br />これらをらーめん・そば・ピザ・etc...全てに作成するのは大変ですから食べ物を作成して、らーめん・そば・ピザ・etc...はこれを継承したら管理が簡単ですよね♪<br />こんな考え方がオブジェクト指向です。<br />理解できなくて当然です。<br />とりあえず、この段階ではオブジェクト指向とは<strong>データ</strong>と<strong>メソッド</strong>をひとまとめにしたものなんだな程度に覚えてください。
<h2>プロパティとメソッド</h2>
オブジェクト指向では、データとメソッドをひとまとめにして管理すると説明しましたね♪<br />オブジェクト指向ではデータをプロパティ、メソッドはそのままメソッドと呼びます。
<p>プロパティのことをフィールドと呼ぶこともあります。</p>
<img src="../pics/オブジェクト.png" alt="オブジェクト" />
また、オブジェクトの属するプロパティとメソッドを総称してメンバと呼びます。
<h2>クラスとインスタンス</h2>
クラスとはオブジェクト指向の考え方において、オブジェクトの雛形となる部分です。<br />オブジェクトの設計図としての役割を持ち、クラスから実際にオブジェクトを作成することでこれを使用します。<br /><br />オブジェクトの設計図としてのオブジェクトをクラスオブジェクト、ないしは単にクラスと呼び、クラスから実際に作成されたオブジェクトをインスタンオブジェクト、ないしは単にインスタンスと呼びます。<br /><br />オブジェクトという名称はクラスオブジェクトを意味するのかインスタンスオブジェクトを意味するのか不明瞭であるため原則として使用しません。
<img src="../pics/クラス・インスタンス.png" alt="クラス・インスタンス" />
たこ焼きってアウトラインは決まっていますよね、、、<img src="../pics/たこ焼き.png" alt="たこ焼き" class="絵文字 x" /><img src="../pics/たこ焼き.png" alt="たこ焼き" class="絵文字 x" /><img src="../pics/たこ焼き.png" alt="たこ焼き" class="絵文字 x" /><br />客によって変えるのはトッピングだとか具材だけですので、雛形を作成してそこから実際のたこ焼きを作ってしまえば楽ちんです。
<h2>オブジェクト指向の目的</h2>
で、なぜクラスを作成してオブジェクト指向を使用するかですよね、、、<br />目的は「見やすく」書くためです。<br />プログラムの寿命が伸びている現在は、プログラムの修正のしやすさ(保守性)がとっても大切です。<br />最初にプログラミングしている時には問題ありませんが、1年後、2年後、さらには5年後にプログラムを修正しようとしてコードを見てもチンプンカンプンですよね、、、<br /><br />クラスを使用して、ある程度データにまとまりを設けていればコードの可読性が向上します。<br /><br />最近は読みやすいコード(リーダブルコード)がとっても重要視されていますので、是非オブジェクト指向をマスターしましょう♪
<h2>オブジェクト指向の特徴</h2>
オブジェクト指向の特徴は以下の3つです。
<ul>
	<li>隠蔽性</li>
	<li>継承性</li>
	<li>多態性</li>
</ul>
<h3>隠蔽性</h3>
オブジェクトの中身へのアクセスを制限することで、データが勝手に書き換えられることを防ぎます。<br />オブジェクト内のデータは定められた専用のメソッドを使用することでデータとそれに関連する処理がまとめられ、コードの可読性向上につながります。
<h3>継承性</h3>
データは階層性質を持つことが多いです。<br />例えば、食べ物には「甘味」「塩味」「酸味」「苦味」「うま味」という性質がありますね♪<br /><br />僕の大好物のラーメンも味噌汁もこの5つの性質を持っています。<br /><br />ラーメンにはさらに「麺の硬さ」「油の多さ」「味の濃さ」という性質が加わり、味噌汁にはさらに「味噌の味」という性質が加わり、、。<br /><br />こんな感じで階層構造になっているデータをオブジェクト指向では簡単に管理することができます。<br /><br />具体的にはラーメンは食べ物オブジェクトを継承することで食べ物オブジェクトが持つ「甘味」「塩味」「酸味」「苦味」「うま味」という性質を使用することができます。
<h3>多態性</h3>
う～～～ん、、、<br />とっても難しい考え方です。<br /><br />辞書的な説明をすると、あるオブジェクトに対して複数の異なる形態を持たせることができます。<br /><br />例えば、「25」と「12.34」はデータの型が整数型と浮動小数点数型で異なるのにも関わらず、演算が可能ですよね♪<br />これが多態性という性質です。<br /><br />分からなければ飛ばしてもok!です。
<h2>クラスの定義</h2>
クラスは以下のように定義します。
<code class="java">
	アクセス修飾子 class クラス名 {
		メンバ1
		メンバ2
		メンバ3
	}
</code>
アクセス修飾子はそのクラスに対してどこからアクセスできるかを指定するもので、通常は省略します。<br /><br />プロパティ・メソッドの定義は変数の宣言と通常のメソッドの定義と同様です。<br /><br />では、簡単なポケモンクラスを定義してみましょう♪
<code class="java">
	class pokemon {
		int no;
		String name;
		public static void hi() {
			System.out.println("hi");
		}
	}
</code>
プロパティとしてint型の図鑑番号とString型の名前を持ち、メソッドとして「hi」と出力するhiメソッドを持ちます。
<h2>インスタンスの生成</h2>
では実際に型であるクラスからインスタンスを生成してみましょう♪<br />インスタンスを生成するには以下のように書きます。
<code class="java">
	クラス名 変数名;
	変数名 = new クラス名();
</code>
一行目の処理は以下のような変数の宣言と同様で、クラスから生成したインスタンスを格納するための変数を宣言します。
<code class="java">
	int n;
	String s;
</code>
クラスはデータ型として扱うことになるためです。<br /><br />二行目は初期化と呼ばれる行為で、実際にクラスからインスタンスを生成して変数に代入します。<br /><br />また、変数の宣言と初期化をまとめて以下のように記述することもできます。
<code class="java">
	クラス名 変数名 = new クラス名();
</code>
また、これ以降はクラスから派生したインスタンスを生成する変数のことをインスタンスと呼ぶことにします。
<div class="separator"></div>
では、実際にpokemonクラスからpikachuインスタンスを生成してみましょう♪
<code class="java">
	pokemon pikachu;
	pikachu = new pokemon();
</code>
<h2>メンバへのアクセス</h2>
インスタンスのメンバにアクセスするには以下のように書きます。
<code class="java">
	インスタンス名.メンバ名
</code>
メンバがメソッドである場合は以下のように記述します。
<code class="java">
	インスタンス名.メソッド名(引数)
</code>
では、先ほど生成したpikachuインスタンスを完成させましょう♪
<code class="java">
	public class koko {
		public static void main(String[] args) {
			pokemon pikachu;
			pikachu = new pokemon();
			pikachu.no = 25;
			pikachu.name = "ピカチュウ";
			pikachu.hi();
			System.out.println(pikachu.no);
			System.out.println(pikachu.name);
		}
	}
	class pokemon {
		int no;
		String name;
		public static void hi() {
			System.out.println("hi");
		}
	}

	/* &darr; コンソール &darr;
	hi
	25
	ピカチュウ
	*/
</code>
<h2>this</h2>
先ほどのhiメソッドはnoプロパティやnameプロパティに関係なく「hi」とコンソール画面に出力するだけでした。<br />オブジェクト指向の強みは複数のプロパティと複数のメソッドを密接に連携させることです。<br />ということで、メソッドからそのメソッドが属するインスタンスの他のメンバにアクセスする必要を学びましょう。<br /><br />各インスタンスごとに以下のようにメンバにアクセスする記法は使用できません。
<code class="java">
	インスタンス名.メンバ名
</code>
インスタンスを複数生成する場合に自分自身を表す「this」キーワードを使用します。<br />したがって、メソッドが属するインスタンスのメソッドにアクセスするには以下のように書きます。
<code class="java">
	this.メンバ名
</code>
thisを使用するにはstatic修飾子をつけてはいけません。<br />ついでにhiメソッドのstatic修飾子も削除しています。<br /><br />では、先ほどのpokemonクラスに自己紹介をするi_amメソッドを追加してみましょう♪
<code class="java">
	class pokemon {
		int no;
		String name;
		public void i_am() {
			System.out.println("私の名前は" + this.name + "で図鑑番号は" + this.no + "です。");
		}
	}
</code>
これで、複数のインスタンスを生成してもぞれぞれで期待通り動作します。<br />ピカチュウ以外にチコリータ(chikorita)とミュウ(mew)インスタンスを生成してみましょう♪
<code class="java">
	public class koko {
		public static void main(String[] args) {
			pokemon pikachu;
			pikachu = new pokemon();
			pikachu.no = 25;
			pikachu.name = "ピカチュウ";
			pikachu.i_am();
			
			pokemon chikorita;
			chikorita = new pokemon();
			chikorita.no = 152;
			chikorita.name = "チコリータ";
			chikorita.i_am();
			
			pokemon mew;
			mew = new pokemon();
			mew.no = 151;
			mew.name = "ミュウ";
			mew.i_am();
		}
	}
	class pokemon {
		int no;
		String name;
		public void i_am() {
			System.out.println("私の名前は" + this.name + "で図鑑番号は" + this.no + "です。");
		}
	}

	/* &darr; コンソール &darr;
	私の名前はピカチュウで図鑑番号は25です。
	私の名前はチコリータで図鑑番号は152です。
	私の名前はミュウで図鑑番号は151です。
	*/
</code>
<h2>コンストラクタ</h2>
インスタンスを生成した後にそのメンバひとつずつにアクセスして値を代入してインスタンスを完成させるのは大変ですし、綺麗ではありませんよね、、、<br />ということで、インスタンス時に自動で実行する方法を紹介します。<br /><br />コンストラクタを使用する方法で、コンストラクタとはインスタンス生成時に自動で実行されるメソッドを言います。<br />これを用いてインスタンスの初期化をします。<br />コンストラクタは以下のように定義します。
<code class="java">
	class クラス名 {
		メンバ1
		メンバ2
		メンバ3
		クラス名(引数1, 引数2, 引数3) {
			this.x = 引数1;
			this.y = 引数2;
			this.z = 引数3;
		}
	}
</code>
通常は引数として受け取った値をそのままインスタンスのプロパティにセットします。<br /><br />コンストラクタに与える引数は初期化時の括弧内でメソッドと同様の方法で渡します。
<code class="java">
	クラス名 変数名 = new クラス名(引数1, 引数2, 引数3);
</code>
では、先ほどのコードをコンストラクタを用いて書き換えてみましょう♪
<code class="java">
	public class koko {
		public static void main(String[] args) {
			pokemon pikachu;
			pikachu = new pokemon(25, "ピカチュウ");
			pikachu.i_am();
			
			pokemon chikorita;
			chikorita = new pokemon(152, "チコリータ");
			chikorita.i_am();
			
			pokemon mew;
			mew = new pokemon(151, "ミュウ");
			mew.i_am();
		}
	}
	class pokemon {
		int no;
		String name;
		public void i_am() {
			System.out.println("私の名前は" + this.name + "で図鑑番号は" + this.no + "です。");
		}
		pokemon (int no, String name) {
			this.no = no;
			this.name = name;
		}
	}

	/* &darr; コンソール &darr;
	私の名前はピカチュウで図鑑番号は25です。
	私の名前はチコリータで図鑑番号は152です。
	私の名前はミュウで図鑑番号は151です。
	*/
</code>
<?php footer(); ?>